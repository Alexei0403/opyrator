
# Log errors to stdout - Tested?
error_log /dev/stdout warn;

events {}

http {
    log_format my_upstream '$remote_addr [$time_local] "$request" $status'
    ' "$upstream_addr" $upstream_response_time $upstream_http_etag $remaining_part';

    # if SERVICE_SSL_ENABLED flag is set, following lines are commented in and the path to the certs is set
    #ssl_certificate
    #ssl_certificate_key

    client_max_body_size 10G;
    client_body_timeout 300s;
    client_header_timeout 120s;

    proxy_connect_timeout 600;
    proxy_send_timeout 600;
    proxy_read_timeout 600;
    send_timeout 600;

    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

     map $upstream_http_location $new_location {
        default .$upstream_http_location;
    }

    server {
        listen 8080;

        #auth_basic "Restricted Access";
        #auth_basic_user_file /etc/nginx/.htpasswd;

        # only do relative redirects
        absolute_redirect off;

        error_page 502 504 /5xx.html;
        error_page 497 https://$http_host$request_uri;

        location = /5xx.html {
            auth_basic off;
            root /resources/;
            internal;
        }

        # location / {
        #     proxy_pass http://jupyter;

        #     proxy_set_header X-Real-IP $remote_addr;
        #     # Todo: change to http_host? host does not include the port (= higher security?)
        #     proxy_set_header Host $host;
        #     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        #     proxy_set_header Origin ""; # set origin to empty, otherwise Jupyter returns a bad origin request

        #     # websocket support
        #     proxy_http_version 1.1;
        #     proxy_set_header Upgrade $http_upgrade;
        #     proxy_set_header Connection "upgrade";
        # }


        location = /ping {
            auth_basic off;
            return 200;
        }

        # if url is called without trailing slash, add a trailing slash, otherwise it cannot be routed correctly.
        location ~* "^{BASE_URL_DECODED}/demos/[^/]+$" {
            # uri is only the path whereas request_uri also contains args
            return 302 $uri/$is_args$args;
        }

        location ~* "^{BASE_URL_DECODED}/demos/(?<demo>[a-zA-Z_]+)/(?<remaining_part>.*)" {
            access_log /var/log/nginx/upstream.log my_upstream;

            # Allow CORS requests
            if ($request_method = OPTIONS) {
                add_header Access-Control-Allow-Origin "$http_origin";
                add_header Access-Control-Allow-Credentials "true";
                add_header Access-Control-Allow-Methods "GET, OPTIONS, DELETE, POST, PUT";
                add_header Access-Control-Allow-Headers "Authorization, Content-Type";
                add_header Content-Length 0;
                add_header Content-Type text/plain;
                return 200;
            }

            if ($demo = playground) {
                set $demo_port 7080;
            }

            if ($remaining_part !~ ^/(.*)$) {
                # add slash to remaining part if it wasn't already added
                # required since base path always starts with slash
                set $remaining_part /$remaining_part;
            }

            # proxy_buffering off;
            proxy_redirect off;
            proxy_set_header Host $host;
            proxy_set_header X-Forwarded-Host $host;
            proxy_set_header X-Forwarded-Server $host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_pass_request_headers on;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            proxy_store off;

            proxy_pass http://127.0.0.1:$demo_port$remaining_part$is_args$args;
            gzip on;
            gzip_proxied any;
            gzip_types *;
        }
    }
}
